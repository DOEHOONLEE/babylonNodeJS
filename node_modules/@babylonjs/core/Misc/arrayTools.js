/* eslint-disable @typescript-eslint/naming-convention */
/**
 * Class containing a set of static utilities functions for arrays.
 */
export class ArrayTools {
    /**
     * Returns an array of the given size filled with elements built from the given constructor and the parameters.
     * @param size the number of element to construct and put in the array.
     * @param itemBuilder a callback responsible for creating new instance of item. Called once per array entry.
     * @returns a new array filled with new objects.
     */
    static BuildArray(size, itemBuilder) {
        const a = [];
        for (let i = 0; i < size; ++i) {
            a.push(itemBuilder());
        }
        return a;
    }
    /**
     * Returns a tuple of the given size filled with elements built from the given constructor and the parameters.
     * @param size he number of element to construct and put in the tuple.
     * @param itemBuilder a callback responsible for creating new instance of item. Called once per tuple entry.
     * @returns a new tuple filled with new objects.
     */
    static BuildTuple(size, itemBuilder) {
        return ArrayTools.BuildArray(size, itemBuilder);
    }
    static _ProxySet(observable, target, property, value) {
        observable.notifyObservers({ target, previousLength: target.length });
        return Reflect.set(target, property, value);
    }
    static _ProxyPushOrUnshift(operation, observable, target, ...values) {
        observable.notifyObservers({ target, previousLength: target.length });
        return operation === "push" ? Array.prototype.push.apply(target, values) : Array.prototype.unshift.apply(target, values);
    }
    static _ProxyDelete(observable, target, property) {
        observable.notifyObservers({ target, previousLength: target.length });
        return Reflect.deleteProperty(target, property);
    }
    static _ProxyPopOrShift(operation, observable, target) {
        const value = operation === "pop" ? Array.prototype.pop.apply(target) : Array.prototype.shift.apply(target);
        observable.notifyObservers({ target, previousLength: target.length });
        return value;
    }
    static _ProxySplice(observable, target, start, deleteNumber, ...added) {
        const values = Array.prototype.splice.apply(target, [start, deleteNumber, added]);
        observable.notifyObservers({ target, previousLength: target.length });
        return values;
    }
    static MakeObservableArray(observable, initialArray) {
        let returnObject;
        if (initialArray && !Object.prototype.hasOwnProperty.call(initialArray, "isObserved")) {
            const _proxyObject = {
                set: (target, property, value) => ArrayTools._ProxySet(observable, target, property, value),
                push: (target, ...values) => ArrayTools._ProxyPushOrUnshift("push", observable, target, ...values),
                unshift: (target, ...values) => ArrayTools._ProxyPushOrUnshift("unshift", observable, target, ...values),
                delete: (target, property) => ArrayTools._ProxyDelete(observable, target, property),
                pop: (target) => ArrayTools._ProxyPopOrShift("pop", observable, target),
                shift: (target) => ArrayTools._ProxyPopOrShift("shift", observable, target),
                splice: (target, start, deleteNumber, ...added) => ArrayTools._ProxySplice(observable, target, start, deleteNumber, ...added),
                isObserved: true,
            };
            returnObject = new Proxy(initialArray, _proxyObject);
        }
        else {
            returnObject = initialArray;
        }
        observable.notifyObservers({ target: returnObject });
        return returnObject;
    }
}
//# sourceMappingURL=arrayTools.js.map