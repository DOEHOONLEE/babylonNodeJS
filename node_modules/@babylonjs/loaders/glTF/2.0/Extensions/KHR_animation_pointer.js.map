{"version":3,"file":"KHR_animation_pointer.js","sourceRoot":"","sources":["../../../../../../../lts/loaders/generated/glTF/2.0/Extensions/KHR_animation_pointer.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { ArrayItem, GLTFLoader } from \"../glTFLoader\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { IAnimation, IAnimationChannel, _IAnimationSamplerData, IAnimationSampler } from \"../glTFLoaderInterfaces\";\r\n\r\nimport { AnimationChannelTargetPath, AnimationSamplerInterpolation } from \"babylonjs-gltf2interface\";\r\nimport { AnimationKeyInterpolation } from \"core/Animations/animationKey\";\r\nimport { CoreAnimationPointerMap } from \"./KHR_animation_pointer.map\";\r\nimport type { GetGltfNodeTargetFn, IAnimationPointerPropertyInfos } from \"./KHR_animation_pointer.map\";\r\nimport { getDataAccessorElementCount } from \"../glTFUtilities\";\r\n\r\nconst NAME = GLTFLoader._KHRAnimationPointerName;\r\n\r\ninterface IAnimationChannelTarget {\r\n    stride?: number;\r\n    target: any;\r\n    properties: Array<IAnimationPointerPropertyInfos>;\r\n    params: any;\r\n}\r\n\r\n/**\r\n * [Specification PR](https://github.com/KhronosGroup/glTF/pull/2147)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_animation_pointer implements IGLTFLoaderExtension {\r\n    /**\r\n     * used to gently ignore invalid pointer. If false, invalid pointer will throw exception.\r\n     */\r\n    public ignoreInvalidPointer: boolean = true;\r\n\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @param loader\r\n     * @hidden\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n    }\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public get enabled(): boolean {\r\n        return this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @hidden */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * according to specification,\r\n     * It is not allowed to animate a glTFid property, as it does change the structure of the glTF in general\r\n     * It is not allowed to animate a name property in general.\r\n     * @param property\r\n     * @hidden\r\n     */\r\n    public accept(property: string): boolean {\r\n        return property != \"name\";\r\n    }\r\n\r\n    public loadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\r\n        // ensure an animation group is present.\r\n        if (!animation._babylonAnimationGroup) {\r\n            this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;\r\n            const group = new AnimationGroup(animation.name || `animation${animation.index}`, this._loader.babylonScene);\r\n            group._parentContainer = this._loader._assetContainer;\r\n            this._loader.babylonScene._blockEntityCollection = false;\r\n            animation._babylonAnimationGroup = group;\r\n        }\r\n        const babylonAnimationGroup = animation._babylonAnimationGroup;\r\n\r\n        const promises = new Array<Promise<any>>();\r\n        ArrayItem.Assign(animation.channels);\r\n        ArrayItem.Assign(animation.samplers);\r\n\r\n        for (const channel of animation.channels) {\r\n            promises.push(this._loadAnimationChannelAsync(`${context}/channels/${channel.index}`, context, animation, channel));\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            babylonAnimationGroup.normalize(0);\r\n            return babylonAnimationGroup;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @hidden Loads a glTF animation channel.\r\n     * @param context The context when loading the asset\r\n     * @param animationContext The context of the animation when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @param channel The glTF animation channel property\r\n     * @param animationTargetOverride The babylon animation channel target override property. My be null.\r\n     * @returns A void promise when the channel load is complete\r\n     */\r\n    public _loadAnimationChannelAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        animationTargetOverride: Nullable<IAnimatable> = null\r\n    ): Promise<void> {\r\n        if (channel.target.path != AnimationChannelTargetPath.POINTER) {\r\n            throw new Error(`${context}/target/path: Invalid value (${channel.target.path})`);\r\n        }\r\n\r\n        if (channel.target.node != undefined) {\r\n            // According to KHR_animation_pointer specification\r\n            // If this extension is used, the animation.channel.target.node must not be set.\r\n            // Because the node is defined, the channel is ignored and not animated due to the specification.\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const pointer = channel.target.extensions?.KHR_animation_pointer?.pointer;\r\n        if (!pointer) {\r\n            throw new Error(`${context}/target/extensions/${this.name}: Pointer is missing`);\r\n        }\r\n\r\n        const sampler = ArrayItem.Get(`${context}/sampler`, animation.samplers, channel.sampler);\r\n\r\n        return this._loadAnimationSamplerAsync(`${context}/samplers/${channel.sampler}`, sampler).then((data) => {\r\n            // this is where we process the pointer.\r\n            const animationTarget = this._parseAnimationPointer(`${context}/extensions/${this.name}/pointer`, pointer);\r\n\r\n            if (!animationTarget) {\r\n                return;\r\n            }\r\n            // build the keys\r\n            // build the animations into the group\r\n            const babylonAnimationGroup = animation._babylonAnimationGroup;\r\n            if (!babylonAnimationGroup) {\r\n                return;\r\n            }\r\n\r\n            const outputAccessor = ArrayItem.Get(`${context}/output`, this._loader.gltf.accessors, sampler.output);\r\n            // stride is the size of each element stored into the output buffer.\r\n            const stride = animationTarget.stride ?? getDataAccessorElementCount(outputAccessor.type);\r\n            const fps = this._loader.parent.targetFps;\r\n\r\n            // we extract the corresponding values from the read value.\r\n            // the reason for that is one GLTF value may be dispatched to several Babylon properties\r\n            // one of example is baseColorFactor which is a Color4 under GLTF and dispatched to\r\n            // - albedoColor as Color3(Color4.r,Color4.g,Color4.b)\r\n            // - alpha as Color4.a\r\n            for (const propertyInfo of animationTarget.properties) {\r\n                // Ignore animations that have no animation valid targets.\r\n                if (!propertyInfo.isValid(animationTarget.target)) {\r\n                    return;\r\n                }\r\n\r\n                // build the keys.\r\n                const keys = new Array(data.input.length);\r\n                let outputOffset = 0;\r\n\r\n                switch (data.interpolation) {\r\n                    case AnimationSamplerInterpolation.STEP: {\r\n                        for (let frameIndex = 0; frameIndex < data.input.length; frameIndex++) {\r\n                            keys[frameIndex] = {\r\n                                frame: data.input[frameIndex] * fps,\r\n                                value: propertyInfo.get(animationTarget.target, data.output, outputOffset),\r\n                                interpolation: AnimationKeyInterpolation.STEP,\r\n                            };\r\n                            outputOffset += stride;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                        const invfps = 1 / fps;\r\n                        for (let frameIndex = 0; frameIndex < data.input.length; frameIndex++) {\r\n                            const k: any = {\r\n                                frame: data.input[frameIndex] * fps,\r\n                            };\r\n\r\n                            (k.inTangent = propertyInfo.get(animationTarget.target, data.output, outputOffset, invfps)), (outputOffset += stride);\r\n                            (k.value = propertyInfo.get(animationTarget.target, data.output, outputOffset)), (outputOffset += stride);\r\n                            (k.outTangent = propertyInfo.get(animationTarget.target, data.output, outputOffset, invfps)), (outputOffset += stride);\r\n\r\n                            keys[frameIndex] = k;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case AnimationSamplerInterpolation.LINEAR:\r\n                    default: {\r\n                        for (let frameIndex = 0; frameIndex < data.input.length; frameIndex++) {\r\n                            keys[frameIndex] = {\r\n                                frame: data.input[frameIndex] * fps,\r\n                                value: propertyInfo.get(animationTarget.target, data.output, outputOffset),\r\n                            };\r\n                            outputOffset += stride;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                // each properties has its own build animation process.\r\n                // these logics are located into KHR_animation_pointer.map.ts\r\n                propertyInfo.buildAnimations(animationTarget.target, fps, keys, babylonAnimationGroup, animationTargetOverride, animationTarget.params);\r\n            }\r\n        });\r\n    }\r\n\r\n    private _loadAnimationSamplerAsync(context: string, sampler: IAnimationSampler): Promise<_IAnimationSamplerData> {\r\n        if (sampler._data) {\r\n            return sampler._data;\r\n        }\r\n\r\n        const interpolation = sampler.interpolation || AnimationSamplerInterpolation.LINEAR;\r\n        switch (interpolation) {\r\n            case AnimationSamplerInterpolation.STEP:\r\n            case AnimationSamplerInterpolation.LINEAR:\r\n            case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/interpolation: Invalid value (${sampler.interpolation})`);\r\n            }\r\n        }\r\n\r\n        const inputAccessor = ArrayItem.Get(`${context}/input`, this._loader.gltf.accessors, sampler.input);\r\n        const outputAccessor = ArrayItem.Get(`${context}/output`, this._loader.gltf.accessors, sampler.output);\r\n        sampler._data = Promise.all([\r\n            this._loader._loadFloatAccessorAsync(`/accessors/${inputAccessor.index}`, inputAccessor),\r\n            this._loader._loadFloatAccessorAsync(`/accessors/${outputAccessor.index}`, outputAccessor),\r\n        ]).then(([inputData, outputData]) => {\r\n            return {\r\n                input: inputData,\r\n                interpolation: interpolation,\r\n                output: outputData,\r\n            };\r\n        });\r\n\r\n        return sampler._data;\r\n    }\r\n\r\n    /**\r\n     * parsing animation pointer is the core of animation channel.\r\n     * Animation pointer is a Json pointer, which mean it locate an item into the json hierarchy.\r\n     * Consequentely the pointer has the following BNF\r\n   \r\n     * <animationPointer> := <sep><assetContainer><sep><assetIndex><sep><propertyPath>\r\n     * <assetContainer> := \"nodes\" | \"materials\" | \"meshes\" | \"cameras\" | \"extensions\" \r\n     * <assetIndex> := <digit> | <name>\r\n     * <propertyPath> := <extensionPath> | <standardPath>\r\n     * <extensionPath> := \"extensions\"<sep><name><sep><standardPath>\r\n     * <standardPath> := <name> | <name><sep><standardPath> \r\n     * <sep>:= \"/\"\r\n     * <name> := W+\r\n     * <digit> := D+\r\n     * \r\n     * examples of pointer are\r\n     *  - \"/nodes/0/rotation\"\r\n     *  - \"/materials/2/emissiveFactor\"\r\n     *  - \"/materials/2/pbrMetallicRoughness/baseColorFactor\"\r\n     *  - \"/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength\"\r\n     * @param context \r\n     * @param pointer \r\n     * @return \r\n     */\r\n    private _parseAnimationPointer(context: string, pointer: string): Nullable<IAnimationChannelTarget> {\r\n        const sep = \"/\";\r\n        if (pointer.charAt(0) == sep) {\r\n            pointer = pointer.substring(1);\r\n        }\r\n        const parts = pointer.split(sep);\r\n        // we have a least 3 part\r\n        if (parts.length >= 3) {\r\n            let node = CoreAnimationPointerMap; // the map of possible path\r\n            const indices = [];\r\n            let getTarget: Nullable<GetGltfNodeTargetFn> = null;\r\n            for (let i = 0; i < parts.length; i++) {\r\n                const part = parts[i];\r\n                node = node[part];\r\n\r\n                if (!node) {\r\n                    // nothing to do so far\r\n                    break;\r\n                }\r\n\r\n                if (node.getTarget) {\r\n                    getTarget = node.getTarget;\r\n                }\r\n\r\n                if (node.hasIndex) {\r\n                    indices.push(parts[++i]);\r\n                    // move to the next part\r\n                    continue;\r\n                }\r\n\r\n                if (node.isIndex) {\r\n                    indices.push(part);\r\n                    // move to the next part\r\n                    continue;\r\n                }\r\n\r\n                if (node.properties && getTarget) {\r\n                    const t = getTarget(this._loader.gltf, indices[0]);\r\n                    if (t != null) {\r\n                        return {\r\n                            target: t,\r\n                            stride: node.getStride ? node.getStride(t) : undefined,\r\n                            properties: node.properties,\r\n                            params: indices,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (this.ignoreInvalidPointer) {\r\n            return null;\r\n        }\r\n        throw new Error(`${context} invalid pointer. ${pointer}`);\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_animation_pointer(loader));\r\n"]}